/*
 * x86-64 assembly language implementations of functions
 */

	.section .text

/* Offsets of struct Image fields */
#define IMAGE_WIDTH_OFFSET   0
#define IMAGE_HEIGHT_OFFSET  4
#define IMAGE_DATA_OFFSET    8

/*
 * TODO: define your helper functions here.
 * Don't forget to use the .globl directive to make
 * them visible to the test code.
 */

/*
 * Implementations of API functions
 */

/*
 * void imgproc_mirror_h( struct Image *input_img, struct Image *output_img );
 *
 * Transform image by mirroring its pixels horizontally.
 * This transformation always succeeds.
 *
 * Parameters:
 *   %rdi - pointer to original struct Image
 *   %rsi - pointer to output struct Image
 */
	.globl imgproc_mirror_h
imgproc_mirror_h:

	/*NOTES: Must use 32-bit versions of the registers if I'm only operating on 32 bits of them.*/
	/* TODO: implement */
	pushq %rbp /* -8 from rsp. Aligned at this point.*/
	movq %rsp, %rbp
	subq $8, %rsp; /*1 local var: height (r12d). rsp will be shifted down by 8. Was aligned from above. 
	; so shift down by another 8, so that after adding the local var, it's aligned to mult of 16 again.
	; so right now it's misaligned but this is anticipating the local var push, after which will be aligned.*/
	
	pushq %r12 /*height. rdi has the width... NEED IT BE r12d? NO - stack is designed to push & pop 8 bytes at a time.
	; so push all 64 bits (pushq) even if only using bottom 32 (movl)*/

	movl IMAGE_HEIGHT_OFFSET(%edi), %r12d; /*r12 will hold the VALUE (not mem address) of the height*/
	/*at this point, p $r12d = 2 for 2x2 image (correct) */

	movl $0, %r10d /*outer loop counter. Use caller saved. No need to reserve more space on stack. "d" for just 32 bits.*/
	movl $0, %r11d /*inner loop counter. Caller-saved*/
	/*at this point, r10d and r11d contain 0 (correct) */


	.LOuterLoop:
		cmpl %r12d, %r10d /* if the outer loop counter r10d >= r12d = height, jump out.*/
		jge .LOuterLoopDone

		.LInnerLoop:
			cmpl %edi, %r11d /*if inner loop counter r11d >= rdi = width. edi lower 32 bits of rdi*/
			jge .LInnerLoopDone

			movl (%edi), %edx /* rdx gets the width, to be used in the [i][j] = col + (width * row) calculation*/
			/*BUG FIX: Changed %edi to (%edi) (before it was loading like 400,000 into edx)*/
			imul %r10d, %edx /* rdx gets (rdx * r10d) i.e. rdx = width * row. Use just lower 32 bits.*/
			/*r10d cannot be dereferenced. Multiply the literal value.*/

			addl %r11d, %edx /* rdx is now (width * row) + col, since r11d has the current col
			 this should be addl %r11d, %edx to use just the 32-bit versions!
			 I don't think I need to do any -1 here because curCol starts from 0 already, going left to right. */



			/* outer loop counter * width + (width - curCol)*/
			movl (%edi), %ecx/* rcx will be index of output img. load width (the value) into rcx*/
			subl %r11d, %ecx /*rcx now has (width - curCol) note curCol = inner loop counter. It is a literal value
			; so no need to dereference r11d*/

			movl %r10d, %r8d /* r8 will have (outer loop counter * width) to add to rcx. Currently has outer loop counter.
			; A literal value so no need to add.
			; QUESTION: should this be just the lower 32 bits?*/
			imul (%edi), %r8d /* r8 now has (outer loop counter * width). Just used lower 32 bits. Not sure if right.
			; dereferenced edi (lower 32 of rdi) to get the literal width value.*/
			addl %r8d, %ecx /* rcx now has the output img index, (curRow * width + (width - curCol))
			; where curRow = outer loop counter, curCol = inner loop counter
			; using just the lower 32 bits.*/
			/*for 2x2 image, ecx was 2 at this point*/
			dec %r8d /*needs to be (curRow * width + (width - curCol - 1) because of 0-based indexing
			it starts at width and goes from right to left, so need the -1 there I think. */

			imul $4, %edx /* multiply by size of uint32_t*/
			addl $IMAGE_DATA_OFFSET, %edx /* add image_data_offset to get total offset from rdi to current pixel of input
			After this, to get to the address of current pixel, just do rdi +edx*/
			/*GDB: for 2x2 image, edx was 8 at this point*/

			/*leaq (%edx)(%edi), %edx /* edx goes from being the offset, to being (base address of input struct) + offset.
			 so basically edx becomes the actual mem address of the current source pixel.*/

			/*DEBUGGING QUESTION: What were edi, edx before this leal?
			$edx was 8
			*/
			leaq (%rdi, %rdx, 1), %rdx /* edx = edi + (edx * 1) 
			Purpose: get to addres of current pixel by doing rdi + edx*/
			/*GDB:  (gdb) x/x $edi
					 0x40b040:       0x00000002
				    (gdb) x/x $edx
					 0x40b048:       0x0040b060
				    (gdb)   
			GDB: on first iter, edx is 8 more than edi. Should be right: edi is base of image, edx is first pixel 8 away
			in GDB, x/x $edx = x/x $rdi + 8 = x/x $edi + 8*/



			imul $4, %ecx /* multiply by size of uint32_t*/
			/*GDB: After this, p $ecx = 8
			x/x $ecx fails: It is simply an address, not a value.*/
			addl $IMAGE_DATA_OFFSET, %ecx /* add image_data_offset to get total offset from rsi to current pixel of output*/
			/*After this, p $ecx = 16*/

			/*leaq (%ecx)(%esi), %ecx /* ecx goes from being the offset, to being (base address of output struct) + offset.
			; so basically after line below, ecx becomes the actual mem address of the current output pixel.*/

			leaq (%rsi, %rcx, 1), %rcx /* ecx = esi + (ecx * 1)  the idea is for rcx to be the actual mem address of 
			the current output pixel */

			/*GDB: After the above line, esi which should just be last 32 bits of rsi, is negative, but rsi is positive.

			CURRENT INPUT PIXEL: rdx
			CURRENT OUTPUT PIXEL: rcx

			*/
			movl (%edx), %r9d      /* Step 1: Load the address of pixel data into r9d */
			movl (%r9d), %r9d      /* Step 2: Dereference r9d to load the actual pixel value 
			"data" is a pointer. Its contents are the memory address of the data. So you need to dereference twice.*/

			movl %r9d, (%rcx) /* Store the 32-bit value from %r9d into the memory address in %ecx */
			/*outdated: seg fault because $ecx is -9088 & cannot access memory at this address*/


			inc %r11d /*increment inner loop counter*/
			jmp .LInnerLoop /*next inner loop iter*/
			

		.LInnerLoopDone:
		inc %r10d /*increment outer loop counter*/
		jmp .LOuterLoop /* next outer loop iter*/

	.LOuterLoopDone:
    /* epilogue.*/
	popq %r12  /*pop callee-saved registers (local vars)*/
	addq $8, %rsp
	popq %rbp
	ret

/*
 * void imgproc_mirror_v( struct Image *input_img, struct Image *output_img );
 *
 * Transform image by mirroring its pixels vertically.
 * This transformation always succeeds.
 *
 * Parameters:
 *   %rdi - pointer to original struct Image
 *   %rsi - pointer to output struct Image
 */
	.globl imgproc_mirror_v
imgproc_mirror_v:
	/* TODO: implement */
	ret

/*
 * int imgproc_tile( struct Image *input_img, int n, struct Image *output_img );
 *
 * Transform image by generating a grid of n x n smaller tiles created by
 * sampling every n'th pixel from the original image.
 *
 * Parameters:
 *   %rdi - pointer to original struct Image
 *   %esi - tiling factor (how many rows and columns of tiles to generate)
 *   %rdx - pointer to the output Image (in which the transformed
 *          pixels should be stored)
 *
 * Returns (in %eax):
 *   1 if successful, or 0 if either
 *     - n is less than 1, or
 *     - the output can't be generated because at least one tile would
 *       be empty (i.e., have 0 width or height)
 */
	.globl imgproc_tile
imgproc_tile:
	/* TODO: implement (this stub implementation just returns 0) */
	xorl %eax, %eax
	ret

/*
 * void imgproc_grayscale( struct Image *input_img, struct Image *output_img );
 *
 * Transform image by converting each pixel to grayscale.
 * This transformation always succeeds.
 *
 * Parameters:
 *   %rdi - pointer to original struct Image
 *   %rsi - pointer to output struct Image
 */
	.globl imgproc_grayscale
imgproc_grayscale:
	/* TODO: implement */
	ret

/*
 * int imgproc_composite( struct Image *base_img, struct Image *overlay_img );
 *
 * Overlay a foreground image on a background image, using each foreground
 * pixel's alpha value to determine its degree of opacity in order to blend
 * it with the corresponding background pixel.
 *
 * Parameters:
 *   %rdi - pointer to base (background) image
 *   %rsi - pointer to overlaid (foreground) image
 *   %rdx - pointer to output Image
 *
 * Returns:
 *   1 if successful, or 0 if the transformation fails because the base
 *   and overlay image do not have the same dimensions
 */
	.globl imgproc_composite
imgproc_composite:
	/* TODO: implement (this stub implementation just returns 0) */
	xorl %eax, %eax
	ret

/*
vim:ft=gas:
*/
